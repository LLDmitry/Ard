// http://codius.ru/articles/GSM_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C_SIM800L_%D1%87%D0%B0%D1%81%D1%82%D1%8C_4

//В следующем примере, для демонстрации управления устройствами будем использовать ту же схему с 3 светодиодами.
//Команды будут состоять из двух цифр — первая цифра будет обозначать номер светодиода(1 - 3), вторая — его состояние(1 — включен, 0 — выключен).
//Для разделения команд, и для того, чтобы микроконтроллер понял что команда введена, каждая команда будет завершаться решеткой #.
//Получается, что допустимых команд(сочетаний цифр) всего 6: 11#, 10#, 21#, 20#, 31#, 30#.Прочие команды будут игнорироваться.
//Если перед решеткой было введено больше чем 2 цифры, будут использованы только 2 последних.Если введено менее 2 цифр или введена некорректная команда, 
//сообщение об этом будет выведено в монитор
//
//Дополнительные параметры позволяют превратить такую простую вещь как DTMF в достаточно мощный инструмент управления.
//В совокупности с получением данных о длительности нажатия каждой клавиши, можно реализовывать механизмы с повышенной степенью защищенности.
//Например, кодовый замок, помимо цифровой комбинации, можно запрограммировать на, специфичные по длительности, удержания каждой из цифр.
//Таким образом получится удвоить уровень безопасности.Для этого необходимо включить режим DTMF с параметром reportMode = 1 — AT + DDET = 1, 0, 1. 
//Теперь, помимо декодированного значения нажатой кнопки, ответ будет содержать через запятую, длительность нажатия в миллисекундах.

#include <SoftwareSerial.h>                           // Библиотека програмной реализации обмена по UART-протоколу
SoftwareSerial SIM800(8, 9);                          // RX, TX

int pins[3] = { 5, 6, 7 };                              // Пины с подключенными светодиодами

String _response = "";                                // Переменная для хранения ответов модуля
void setup() {
  for (int i = 0; i < 3; i++) {
    pinMode(pins[i], OUTPUT);
  }

  Serial.begin(9600);                                 // Скорость обмена данными с компьютером
  SIM800.begin(9600);                                 // Скорость обмена данными с модемом
  Serial.println("Start!");
  _response = sendATCommand("AT", true);              // Проверка общего статуса
  _response = sendATCommand("AT+DDET=1,0,0", true);   // Включаем DTMF
}

String sendATCommand(String cmd, bool waiting) {
  String _resp = "";                                  // Переменная для хранения результата
  Serial.println(cmd);                                // Дублируем команду в монитор порта
  SIM800.println(cmd);                                // Отправляем команду модулю
  if (waiting) {                                      // Если необходимо дождаться ответа...
    _resp = waitResponse();                           // ... ждем, когда будет передан ответ
    // Если Echo Mode выключен (ATE0), то эти 3 строки можно закомментировать
    if (_resp.startsWith(cmd)) {                      // Убираем из ответа дублирующуюся команду
      _resp = _resp.substring(_resp.indexOf("\r\n", cmd.length()) + 2);
    }
    Serial.println(_resp);                            // Дублируем ответ в монитор порта
  }
  return _resp;                                       // Возвращаем результат. Пусто, если проблема
}

String waitResponse() {                               // Функция ожидания ответа и возврата полученного результата
  String _resp = "";                                  // Переменная для хранения результата
  long _timeout = millis() + 10000;                   // Переменная для отслеживания таймаута (10 секунд)
  while (!SIM800.available() && millis() < _timeout)  {}; // Ждем ответа 10 секунд, если пришел ответ или наступил таймаут, то...
  if (SIM800.available()) {                           // Если есть, что считывать...
    _resp = SIM800.readString();                      // ... считываем и запоминаем
  }
  else {                                              // Если пришел таймаут, то...
    Serial.println("Timeout...");                     // ... оповещаем об этом и...
  }
  return _resp;                                       // ... возвращаем результат. Пусто, если проблема
}

void loop() {
  if (SIM800.available())   {                         // Если модем, что-то отправил...
    _response = waitResponse();                       // Получаем ответ от модема для анализа
    Serial.println(">" + _response);                  // Выводим поученную пачку сообщений
    int index = -1;
    do  {                                             // Перебираем построчно каждый пришедший ответ
      index = _response.indexOf("\r\n");              // Получаем идекс переноса строки
      String submsg = "";
      if (index > -1) {                               // Если перенос строки есть, значит
        submsg = _response.substring(0, index);       // Получаем первую строку
        _response = _response.substring(index + 2);   // И убираем её из пачки
      }
      else {                                          // Если больше переносов нет
        submsg = _response;                           // Последняя строка - это все, что осталось от пачки
        _response = "";                               // Пачку обнуляем
      }
      submsg.trim();                                  // Убираем пробельные символы справа и слева
      if (submsg != "") {                             // Если строка значимая (не пустая), то распознаем уже её
        Serial.println("submessage: " + submsg);
        if (submsg.startsWith("+DTMF:")) {            // Если ответ начинается с "+DTMF:" тогда:
          String symbol = submsg.substring(7, 8);     // Выдергиваем символ с 7 позиции длиной 1 (по 8)
          processingDTMF(symbol);                     // Логику выносим для удобства в отдельную функцию
        }
        else if (submsg.startsWith("RING")) {         // При входящем звонке...
          sendATCommand("ATA", true);                 // ...отвечаем (поднимаем трубку)
        }
      }
    } while (index > -1);                             // Пока индекс переноса строки действителен
  }
  if (Serial.available())  {                          // Ожидаем команды по Serial...
    SIM800.write(Serial.read());                      // ...и отправляем полученную команду модему
  };
}

// Отдельная функция для логики DTMF
String result = "";                                   // Переменная для хранения вводимых данных
void processingDTMF(String symbol) {
  Serial.println("Key: " + symbol);                   // Выводим в Serial для контроля, что ничего не потерялось
  if (symbol == "#") {
    bool correct = false;                             // Для оптимизации кода, переменная корректности команды
    if (result.length() == 2) {
      int ledIndex = ((String)result[0]).toInt();     // Получаем первую цифру команды - адрес устройства (1-3)
      int ledState = ((String)result[1]).toInt();     // Получаем вторую цифру команды - состояние (0 - выкл, 1 - вкл)
      if (ledIndex >= 1 && ledIndex <= 3 && (ledState == 0 or ledState == 1)) { // Если все нормально, исполняем команду
        Serial.println("LED:" + (String)ledIndex + " set to " + (ledState == 0 ? "OFF" : "ON"));
        digitalWrite(pins[ledIndex - 1], ledState);   // Исполняем команду
        correct = true;                               // Флаг корректности команды
      }
    }
    if (!correct) Serial.println("Incorrect command: " + result); // Если команда некорректна, выводим сообщение
    result = "";                                      // После каждой решетки сбрасываем вводимую комбинацию
  }
  else if (symbol != "*") {                          // Игнорируем звездочки
    if (result.length() >= 2) {                       // Если в переменной result уже есть цифры, вытесняем первую и добавляем вновь прибывшую
      result = result.substring(1, 2) + symbol;
    }
    else {
      result += symbol;                               // Если нет, добавляем в конец
    }
  }
}
